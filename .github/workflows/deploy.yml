name: Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        default: 'production'
        options:
          - production
      services:
        description: 'Services to deploy (comma-separated, or "all")'
        required: false
        default: 'all'
        type: string
  repository_dispatch:
    types: [image-pushed]

concurrency:
  group: deploy-production
  cancel-in-progress: false

env:
  SSH_OPTS: -i ~/.ssh/deploy_key -p ${{ vars.DEPLOY_SSH_PORT || 22 }} -o StrictHostKeyChecking=accept-new
  SSH_TARGET: ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_SERVER_IP }}
  DEPLOY_PATH: ${{ vars.DEPLOY_PATH || '/opt/olympusoss/prod' }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'production' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -p ${{ vars.DEPLOY_SSH_PORT || 22 }} ${{ secrets.DEPLOY_SERVER_IP }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Ensure deploy directory exists
        run: |
          ssh ${{ env.SSH_OPTS }} ${{ env.SSH_TARGET }} \
            "mkdir -p ${{ env.DEPLOY_PATH }}"

      - name: Sync configs to Droplet
        run: |
          rsync -avz --delete \
            --exclude '.env' \
            --exclude '.env.example' \
            -e "ssh ${{ env.SSH_OPTS }}" \
            ./prod/ ${{ env.SSH_TARGET }}:${{ env.DEPLOY_PATH }}/

      - name: Generate .env
        run: |
          ssh ${{ env.SSH_OPTS }} ${{ env.SSH_TARGET }} "cat > ${{ env.DEPLOY_PATH }}/.env << 'ENVEOF'
          # Auto-generated by GitHub Actions — do not edit manually.
          # Source: deploy.yml workflow, environment: ${{ github.event.inputs.environment || 'production' }}
          # Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)

          # Domain URLs
          CIAM_HERA_PUBLIC_URL=${{ vars.CIAM_HERA_PUBLIC_URL }}
          IAM_HERA_PUBLIC_URL=${{ vars.IAM_HERA_PUBLIC_URL }}
          CIAM_HYDRA_PUBLIC_URL=${{ vars.CIAM_HYDRA_PUBLIC_URL }}
          IAM_HYDRA_PUBLIC_URL=${{ vars.IAM_HYDRA_PUBLIC_URL }}
          CIAM_ATHENA_PUBLIC_URL=${{ vars.CIAM_ATHENA_PUBLIC_URL }}
          IAM_ATHENA_PUBLIC_URL=${{ vars.IAM_ATHENA_PUBLIC_URL }}
          SITE_PUBLIC_URL=${{ vars.SITE_PUBLIC_URL }}

          # PostgreSQL
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_SSLMODE=disable

          # CIAM Kratos
          CIAM_KRATOS_SECRET_COOKIE=${{ secrets.CIAM_KRATOS_SECRET_COOKIE }}
          CIAM_KRATOS_SECRET_CIPHER=${{ secrets.CIAM_KRATOS_SECRET_CIPHER }}

          # IAM Kratos
          IAM_KRATOS_SECRET_COOKIE=${{ secrets.IAM_KRATOS_SECRET_COOKIE }}
          IAM_KRATOS_SECRET_CIPHER=${{ secrets.IAM_KRATOS_SECRET_CIPHER }}

          # CIAM Hydra
          CIAM_HYDRA_SECRET_SYSTEM=${{ secrets.CIAM_HYDRA_SECRET_SYSTEM }}
          CIAM_HYDRA_PAIRWISE_SALT=${{ secrets.CIAM_HYDRA_PAIRWISE_SALT }}

          # IAM Hydra
          IAM_HYDRA_SECRET_SYSTEM=${{ secrets.IAM_HYDRA_SECRET_SYSTEM }}
          IAM_HYDRA_PAIRWISE_SALT=${{ secrets.IAM_HYDRA_PAIRWISE_SALT }}

          # CORS
          CIAM_CORS_ALLOWED_ORIGINS=${{ vars.CIAM_HERA_PUBLIC_URL }},${{ vars.CIAM_ATHENA_PUBLIC_URL }}
          IAM_CORS_ALLOWED_ORIGINS=${{ vars.IAM_HERA_PUBLIC_URL }},${{ vars.IAM_ATHENA_PUBLIC_URL }}

          # SMTP (Resend)
          RESEND_API_KEY=${{ secrets.RESEND_API_KEY }}
          SMTP_FROM_EMAIL=${{ vars.SMTP_FROM_EMAIL }}
          SMTP_CONNECTION_URI=smtps://resend:${{ secrets.RESEND_API_KEY }}@smtp.resend.com:465/

          # OAuth2 — CIAM Athena
          ATHENA_CIAM_OAUTH_CLIENT_ID=${{ vars.ATHENA_CIAM_OAUTH_CLIENT_ID || 'athena-ciam-client' }}
          ATHENA_CIAM_OAUTH_CLIENT_SECRET=${{ secrets.ATHENA_CIAM_OAUTH_CLIENT_SECRET }}

          # OAuth2 — IAM Athena
          ATHENA_IAM_OAUTH_CLIENT_ID=${{ vars.ATHENA_IAM_OAUTH_CLIENT_ID || 'athena-iam-client' }}
          ATHENA_IAM_OAUTH_CLIENT_SECRET=${{ secrets.ATHENA_IAM_OAUTH_CLIENT_SECRET }}

          # OAuth2 — Site (optional)
          SITE_CIAM_CLIENT_ID=${{ vars.SITE_CIAM_CLIENT_ID || 'site-ciam-client' }}
          SITE_CIAM_CLIENT_SECRET=${{ secrets.SITE_CIAM_CLIENT_SECRET }}
          SITE_IAM_CLIENT_ID=${{ vars.SITE_IAM_CLIENT_ID || 'site-iam-client' }}
          SITE_IAM_CLIENT_SECRET=${{ secrets.SITE_IAM_CLIENT_SECRET }}

          # Image tags
          HERA_IMAGE_TAG=${{ vars.HERA_IMAGE_TAG || 'latest' }}
          ATHENA_IMAGE_TAG=${{ vars.ATHENA_IMAGE_TAG || 'latest' }}
          SITE_IMAGE_TAG=${{ vars.SITE_IMAGE_TAG || 'latest' }}

          # Admin identity (used by seed)
          ADMIN_EMAIL=${{ vars.ADMIN_EMAIL || 'admin@example.com' }}
          ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}
          ENVEOF"

      - name: Login to GHCR on Droplet
        run: |
          ssh ${{ env.SSH_OPTS }} ${{ env.SSH_TARGET }} \
            "echo '${{ secrets.GHCR_PAT }}' | docker login ghcr.io -u ${{ vars.GHCR_USERNAME }} --password-stdin"

      - name: Pull latest images
        run: |
          ssh ${{ env.SSH_OPTS }} ${{ env.SSH_TARGET }} \
            "cd ${{ env.DEPLOY_PATH }} && docker compose pull"

      - name: Deploy services
        run: |
          SERVICES="${{ github.event.inputs.services || github.event.client_payload.services || 'all' }}"
          ssh ${{ env.SSH_OPTS }} ${{ env.SSH_TARGET }} \
            "cd ${{ env.DEPLOY_PATH }} && \
             if [ '${SERVICES}' = 'all' ]; then \
               docker compose up -d; \
             else \
               docker compose up -d ${SERVICES}; \
             fi"

      - name: Seed (idempotent)
        run: |
          ssh ${{ env.SSH_OPTS }} ${{ env.SSH_TARGET }} \
            "cd ${{ env.DEPLOY_PATH }} && \
             docker compose --profile seed run --rm seed"

      - name: Wait for services to be healthy
        run: |
          ssh ${{ env.SSH_OPTS }} ${{ env.SSH_TARGET }} \
            "cd ${{ env.DEPLOY_PATH }} && \
             echo 'Waiting for services to stabilize...' && \
             sleep 15 && \
             docker compose ps --format 'table {{.Name}}\t{{.Status}}'"

      - name: Health check summary
        run: |
          ssh ${{ env.SSH_OPTS }} ${{ env.SSH_TARGET }} \
            "cd ${{ env.DEPLOY_PATH }} && \
             echo '=== Service Health ===' && \
             docker compose ps --format 'table {{.Name}}\t{{.Status}}\t{{.Ports}}'"

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/deploy_key
